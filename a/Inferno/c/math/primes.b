#
#	initially generated by c2l
#

implement Primes;

include "draw.m";

Primes: module
{
	init: fn(nil: ref Draw->Context, argl: list of string);
};

include "sys.m";
	sys: Sys;
include "math.m";
	maths: Math;

init(nil: ref Draw->Context, argl: list of string)
{
	sys = load Sys Sys->PATH;
	maths = load Math Math->PATH;
	main(len argl, argl);
}

bigx: real = 9.007199254740992e15;
PTLEN: con 50;
pt := array[PTLEN] of {
	2,
	3,
	5,
	7,
	11,
	13,
	17,
	19,
	23,
	29,
	31,
	37,
	41,
	43,
	47,
	53,
	59,
	61,
	67,
	71,
	73,
	79,
	83,
	89,
	97,
	101,
	103,
	107,
	109,
	113,
	127,
	131,
	137,
	139,
	149,
	151,
	157,
	163,
	167,
	173,
	179,
	181,
	191,
	193,
	197,
	199,
	211,
	223,
	227,
	229,
};
WHLEN: con 48;
wheel := array[WHLEN] of {
	real 10,
	real 2,
	real 4,
	real 2,
	real 4,
	real 6,
	real 2,
	real 6,
	real 4,
	real 2,
	real 4,
	real 6,
	real 6,
	real 2,
	real 6,
	real 4,
	real 2,
	real 6,
	real 4,
	real 6,
	real 8,
	real 4,
	real 2,
	real 4,
	real 2,
	real 4,
	real 8,
	real 6,
	real 4,
	real 6,
	real 2,
	real 4,
	real 6,
	real 2,
	real 6,
	real 6,
	real 4,
	real 2,
	real 4,
	real 6,
	real 2,
	real 6,
	real 4,
	real 2,
	real 4,
	real 2,
	real 10,
	real 2,
};
BITS: con 8;
TABLEN: con 1000;
table := array[TABLEN] of byte;
bittab := array[8] of {
	byte 1,
	byte 2,
	byte 4,
	byte 8,
	byte 16,
	byte 32,
	byte 64,
	byte 128,
};

main(argc: int, argp: list of string)
{
	i: int;
	k, temp, v, limit, nn: real;

	if(argc <= 1){
		sys->fprint(sys->fildes(2), "usage: primes starting [ending]\n");
		exit;
	}
	nn = real hd tl argp;
	limit = bigx;
	if(argc > 2){
		limit = real hd tl tl argp;
		if(limit < nn)
			exit;
		if(limit > bigx)
			ouch();
	}
	if(nn < real 0 || nn > bigx)
		ouch();
	if(nn == real 0)
		nn = real 1;
	if(nn < real 230){
		for(i = 0; i < PTLEN; i++){
			if(real pt[i] < nn)
				continue;
			if(real pt[i] > limit)
				exit;
			sys->print("%d\n", pt[i]);
			if(limit >= bigx)
				exit;
		}
		nn = real 230;
	}
	(itemp, nil) := maths->modf(nn/real 2);
	temp = real itemp;
	nn = 2.*temp+real 1;
	# 
	#  *	clear the sieve table.
	#  
	for(;;){
		for(i = 0; i < TABLEN; i++)
			table[i] = byte 0;
		# 
		#  *	run the sieve.
		#  
		v = maths->sqrt(nn+real (TABLEN*BITS));
		mark(nn, 3);
		mark(nn, 5);
		mark(nn, 7);
		for((i, k) = (0, real 11); k <= v; k += wheel[i]){
			mark(nn, int k);
			i++;
			if(i >= WHLEN)
				i = 0;
		}
		# 
		#  *	now get the primes from the table
		#  *	and print them.
		#  
		for(i = 0; i < TABLEN*BITS; i += 2){
			if(int table[i>>3]&int bittab[i&8r7])
				continue;
			temp = nn+real i;
			if(temp > limit)
				exit;
			sys->print("%d\n", int temp);
			if(limit >= bigx)
				exit;
		}
		nn += real (TABLEN*BITS);
	}
}

mark(nn: real, k: int)
{
	t1: real;
	j: int;

	(it1, nil) := maths->modf(nn/real k);
	t1 = real it1;
	j = int (real k*t1-nn);
	if(j < 0)
		j += k;
	for(; j < TABLEN*BITS; j += k)
		table[j>>3] |= bittab[j&8r7];
}

ouch()
{
	sys->fprint(sys->fildes(2), "limits exceeded\n");
	exit;
}

