#
#	initially generated by c2l
#

dorecipe(node: ref Node): int
{
	buf := array[BIGBLOCK] of byte;
	n: ref Node;
	r: ref Rule = nil;
	a, aa: ref Arc;
	head := ref Word;
	ahead := ref Word;
	lp := ref Word;
	ln := ref Word;
	w, ww, aw: ref Word;
	s: ref Symtab;
	did: int = 0;

	aa = nil;
	# 
	# 		pick up the rule
	# 	
	for(a = node.prereqs; a != nil; a = a.next)
		if(int a.r.recipe[0])
			r = (aa = a).r;
	# 
	# 		no recipe? go to buggery!
	# 	
	if(r == nil){
		if(!(node.flags&VIRTUAL) && !(node.flags&NORECIPE)){
			sys->fprint(sys->fildes(2), "mk: no recipe to make '%s'\n", libc0->ab2s(node.name));
			Exit();
		}
		if(libc0->strchr(node.name, '(') != nil && node.time == 0)
			node.flags = node.flags&~(NOTMADE|BEINGMADE|MADE)|MADE;
		else
			update(0, node);
		if(tflag){
			if(!(node.flags&VIRTUAL))
				touch(node.name);
			else if(explain != nil)
				bout.puts(sys->sprint("no touch of virtual '%s'\n", libc0->ab2s(node.name)));
		}
		return did;
	}
	# 
	# 		build the node list
	# 	
	node.next = nil;
	head.next = nil;
	ww = head;
	ahead.next = nil;
	aw = ahead;
	if(r.attr&REGEXP){
		ww.next = newword(node.name);
		aw.next = newword(node.name);
	}
	else{
		for(w = r.alltargets; w != nil; w = w.next){
			if(r.attr&META)
				subst(aa.stem, w.s, buf);
			else
				libc0->strcpy(buf, w.s);
			aw.next = newword(buf);
			aw = aw.next;
			if((s = symlooki(buf, S_NODE, 0)) == nil)
				continue;	#  not a node we are interested in 
			n = s.nvalue;
			if(aflag == 0 && n.time){
				for(a = n.prereqs; a != nil; a = a.next)
					if(a.n != nil && outofdate(n, a, 0))
						break;
				if(a == nil)
					continue;
			}
			ww.next = newword(buf);
			ww = ww.next;
			if(n == node)
				continue;
			n.next = node.next;
			node.next = n;
		}
	}
	for(n = node; n != nil; n = n.next)
		if((n.flags&READY) == 0)
			return did;
	# 
	# 		gather the params for the job
	# 	
	lp.next = ln.next = nil;
	for(n = node; n != nil; n = n.next){
		for(a = n.prereqs; a != nil; a = a.next){
			if(a.n != nil){
				addw(lp, a.n.name);
				if(outofdate(n, a, 0)){
					addw(ln, a.n.name);
					if(explain != nil)
						sys->fprint(sys->fildes(1), "%s(%d) < %s(%d)\n", libc0->ab2s(n.name), n.time, libc0->ab2s(a.n.name), a.n.time);
				}
			}
			else{
				if(explain != nil)
					sys->fprint(sys->fildes(1), "%s has no prerequisites\n", libc0->ab2s(n.name));
			}
		}
		n.flags = n.flags&~(NOTMADE|BEINGMADE|MADE)|BEINGMADE;
	}
	# print("lt=%s ln=%s lp=%s\n",wtos(head.next, ' '),wtos(ln.next, ' '),wtos(lp.next, ' '));/*
	run(newjob(r, node, aa.stem, aa.match, lp.next, ln.next, head.next, ahead.next));
	return 1;
}

addw(w: ref Word, s: array of byte)
{
	lw: ref Word;

	for(lw = w; (w = w.next) != nil; lw = w){
		if(libc0->strcmp(s, w.s) == 0)
			return;
	}
	lw.next = newword(s);
}

