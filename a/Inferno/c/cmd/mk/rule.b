#
#	initially generated by c2l
#

lr, lmr: ref Rule;
nrules: int = 0;

addrule(head: array of byte, tail: ref Word, body: array of byte, ahead: ref Word, attr: int, hline: int, prog: array of byte)
{
	r, rr: ref Rule;
	sym: ref Symtab;
	reuse: int;

	r = nil;
	reuse = 0;
	if((sym = symlooki(head, S_TARGET, 0)) != nil){
		for(r = sym.rvalue; r != nil; r = r.chain)
			if(rcmp(r, head, tail) == 0){
				reuse = 1;
				break;
			}
	}
	if(r == nil)
		r = ref Rule;
	r.target = head;
	r.tail = tail;
	r.recipe = body;
	r.line = hline;
	r.file = infile;
	r.attr = attr;
	r.alltargets = ahead;
	r.prog = prog;
	r.rule = nrules++;
	if(!reuse){
		rr = symlookr(head, S_TARGET, r).rvalue;
		if(rr != r){
			r.chain = rr.chain;
			rr.chain = r;
		}
		else
			r.chain = nil;
	}
	if(!reuse)
		r.next = nil;
	if(attr&REGEXP || charin(head, libc0->s2ab("%&")) != nil){
		r.attr |= META;
		if(reuse)
			return;
		if(attr&REGEXP){
			patrule = r;
			e := "";
			(r.pat, e) = regex->compile(libc0->ab2s(head), 1);
			if(e != nil)
				perrors(sys->sprint("%s: %s", libc0->ab2s(head), e));
		}
		if(metarules == nil)
			metarules = lmr = r;
		else{
			lmr.next = r;
			lmr = r;
		}
	}
	else{
		if(reuse)
			return;
		r.pat = nil;
		if(rules == nil)
			rules = lr = r;
		else{
			lr.next = r;
			lr = r;
		}
	}
}

dumpr(s: array of byte, r: ref Rule)
{
	bout.puts(sys->sprint("%s: start=%x\n", libc0->ab2s(s), r));
	for(; r != nil; r = r.next){
		bout.puts(sys->sprint("\tRule %x: %s[%d] attr=%x next=%x chain=%x alltarget='%s'", r, libc0->ab2s(r.file), r.line, r.attr, r.next, r.chain, wtostr(r.alltargets, ' ')));
		if(r.prog != nil)
			bout.puts(sys->sprint(" prog='%s'", libc0->ab2s(r.prog)));
		bout.puts(sys->sprint("\n\ttarget=%s: %s\n", libc0->ab2s(r.target), wtostr(r.tail, ' ')));
		bout.puts(sys->sprint("\trecipe@%x='%s'\n", r.recipe, libc0->ab2s(r.recipe)));
	}
}

rcmp(r: ref Rule, target: array of byte, tail: ref Word): int
{
	w: ref Word;

	if(libc0->strcmp(r.target, target))
		return 1;
	for(w = r.tail; w != nil && tail != nil; (w, tail) = (w.next, tail.next))
		if(libc0->strcmp(w.s, tail.s))
			return 1;
	return w != nil || tail != nil;
}

rulecnt(): array of byte
{
	s: array of byte;

	s = array[nrules] of byte;
	for(i := 0; i < nrules; i++)
		s[i] = byte 0;
	return s;
}

