#
#	initially generated by c2l
#

ENVQUANTA: con 10;

envy: array of Envy;
nextv: int;
myenv: array of array of byte;

initenv()
{
	p: int;

	myenv = array[19] of {
		libc0->s2ab("target"),
		libc0->s2ab("stem"),
		libc0->s2ab("prereq"),
		libc0->s2ab("pid"),
		libc0->s2ab("nproc"),
		libc0->s2ab("newprereq"),
		libc0->s2ab("alltarget"),
		libc0->s2ab("newmember"),
		libc0->s2ab("stem0"),	#  must be in order from here 
		libc0->s2ab("stem1"),
		libc0->s2ab("stem2"),
		libc0->s2ab("stem3"),
		libc0->s2ab("stem4"),
		libc0->s2ab("stem5"),
		libc0->s2ab("stem6"),
		libc0->s2ab("stem7"),
		libc0->s2ab("stem8"),
		libc0->s2ab("stem9"),
		array of byte nil,
	};

	for(p = 0; myenv[p] != nil; p++)
		symlooks(myenv[p], S_INTERNAL, libc0->s2ab(""));
	readenv();	#  o.s. dependent 
}

envsize: int;

envinsert(name: array of byte, value: ref Word)
{
	if(nextv >= envsize){
		envsize += ENVQUANTA;
		es := len envy;
		ne := array[envsize] of Envy;
		if(es)
			ne[0: ] = envy[0: es];
		envy = ne;
	}
	envy[nextv].name = name;
	envy[nextv++].values = value;
}

envupd(name: array of byte, value: ref Word)
{
	e: int;

	for(e = 0; envy[e].name != nil; e++)
		if(libc0->strcmp(name, envy[e].name) == 0){
			delword(envy[e].values);
			envy[e].values = value;
			return;
		}
	envy[e].name = name;
	envy[e].values = value;
	envinsert(nil, nil);
}

ecopy(s: ref Symtab)
{
	p: int;

	if(symlooki(s.name, S_NOEXPORT, 0) != nil)
		return;
	for(p = 0; myenv[p] != nil; p++)
		if(libc0->strcmp(myenv[p], s.name) == 0)
			return;
	envinsert(s.name, s.wvalue);
}

execinit()
{
	p: int;

	nextv = 0;
	for(p = 0; myenv[p] != nil; p++)
		envinsert(myenv[p], stow(libc0->s2ab("")));
	symtraverse(S_VAR, ECOPY);
	envinsert(nil, nil);
}

buildenv(j: ref Job, slot: int): array of Envy
{
	p: int;
	cp, qp: array of byte;
	w, v: ref Word;
	l: ref Word;
	i: int;
	buf := array[256] of byte;

	envupd(libc0->s2ab("target"), wdup(j.t));
	if(j.r.attr&REGEXP)
		envupd(libc0->s2ab("stem"), newword(libc0->s2ab("")));
	else
		envupd(libc0->s2ab("stem"), newword(j.stem));
	envupd(libc0->s2ab("prereq"), wdup(j.p));
	stob(buf, sys->sprint("%d", sys->pctl(0, nil)));
	envupd(libc0->s2ab("pid"), newword(buf));
	stob(buf, sys->sprint("%d", slot));
	envupd(libc0->s2ab("nproc"), newword(buf));
	envupd(libc0->s2ab("newprereq"), wdup(j.np));
	envupd(libc0->s2ab("alltarget"), wdup(j.at));
	l = ref Word;
	l.next = v = w = wdup(j.np);
	while(w != nil){
		cp = libc0->strchr(w.s, '(');
		if(cp != nil){
			cp = cp[1: ];
			qp = libc0->strchr(cp, ')');
			if(qp != nil){
				qp[0] = byte 0;
				libc0->strcpy(w.s, cp);
				l.next = w;
				l = w;
				w = w.next;
				continue;
			}
		}
		l.next = w.next;
		w.s = nil;
		w = nil;
		w = l.next;
	}
	v = l.next;
	envupd(libc0->s2ab("newmember"), v);
	#  update stem0 -> stem9 
	for(p = 0; myenv[p] != nil; p++)
		if(libc0->strcmp(myenv[p], libc0->s2ab("stem0")) == 0)
			break;
	for(i = 0; myenv[p] != nil; i++){
		if(j.r.attr&REGEXP && j.match[i] != nil)
			envupd(myenv[p], newword(j.match[i]));
		else
			envupd(myenv[p], newword(libc0->s2ab("")));
		p++;
	}
	return envy;
}

