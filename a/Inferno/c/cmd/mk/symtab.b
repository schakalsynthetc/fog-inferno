#
#	initially generated by c2l
#

NHASH: con 4099;
HASHMUL: con 79;

hash := array[NHASH] of ref Symtab;

syminit()
{
	s: ref Symtab;
	ss, ns: ref Symtab;

	for(i := 0; i < NHASH; i++){
		s = hash[i];
		for(ss = s; ss != nil; ss = ns){
			ns = s.next;
			ss = nil;
		}
		hash[i] = nil;
	}
}

symval(sym: ref Symtab): int
{
	return sym.svalue != nil ||
		   sym.ivalue != 0 ||
		   sym.nvalue != nil ||
		   sym.rvalue != nil ||
		   sym.wvalue != nil;
}
		
symlooks(sym: array of byte, space: int, s: array of byte): ref Symtab
{
	return symlook(sym, space, s != nil, s, 0, nil, nil, nil);
}

symlooki(sym: array of byte, space: int, i: int): ref Symtab
{
	return symlook(sym, space, i != 0, nil, i, nil, nil, nil);
}

symlookn(sym: array of byte, space: int, n: ref Node): ref Symtab
{
	return symlook(sym, space, n != nil, nil, 0, n, nil, nil);
}

symlookr(sym: array of byte, space: int, r: ref Rule): ref Symtab
{
	return symlook(sym, space, r != nil, nil, 0, nil, r, nil);
}

symlookw(sym: array of byte, space: int, w: ref Word): ref Symtab
{
	return symlook(sym, space, w != nil, nil, 0, nil, nil, w);
}

symlook(sym: array of byte, space: int, install: int, sv: array of byte, iv: int, nv: ref Node, rv: ref Rule, wv: ref Word): ref Symtab
{
	h: int;
	p: array of byte;
	s: ref Symtab;

	for((p, h) = (sym, space); int p[0]; ){
		h *= HASHMUL;
		h += int p[0];
		p = p[1: ];
	}
	if(h < 0)
		h = ~h;
	h %= NHASH;
	for(s = hash[h]; s != nil; s = s.next)
		if(s.space == space && libc0->strcmp(s.name, sym) == 0)
			return s;
	if(install == 0)
		return nil;
	s = ref Symtab;
	s.space = space;
	s.name = sym;
	s.svalue = sv;
	s.ivalue = iv;
	s.nvalue = nv;
	s.rvalue = rv;
	s.wvalue = wv;
	s.next = hash[h];
	hash[h] = s;
	return s;
}

symdel(sym: array of byte, space: int)
{
	h: int;
	p: array of byte;
	s, ls: ref Symtab;

	#  multiple memory leaks 
	for((p, h) = (sym, space); int p[0]; ){
		h *= HASHMUL;
		h += int p[0];
		p = p[1: ];
	}
	if(h < 0)
		h = ~h;
	h %= NHASH;
	for((s, ls) = (hash[h], nil); s != nil; (ls, s) = (s, s.next))
		if(s.space == space && libc0->strcmp(s.name, sym) == 0){
			if(ls != nil)
				ls.next = s.next;
			else
				hash[h] = s.next;
			s = nil;
		}
}

symtraverse(space: int, fnx: int)
{
	s: ref Symtab;
	ss: ref Symtab;

	for(i := 0; i < NHASH; i++){
		s = hash[i];
		for(ss = s; ss != nil; ss = ss.next)
			if(ss.space == space){
				if(fnx == ECOPY)
					ecopy(ss);
				else if(fnx == PRINT1)
					print1(ss);
			}
	}
}

symstat()
{
	s: ref Symtab;
	ss: ref Symtab;
	n: int;
	l := array[1000] of int;

	for(i := 0; i < 1000; i++)
		l[i] = 0;
	for(i = 0; i < NHASH; i++){
		s = hash[i];
		for((ss, n) = (s, 0); ss != nil; ss = ss.next)
			n++;
		l[n]++;
	}
	for(n = 0; n < 1000; n++)
		if(l[n])
			bout.puts(sys->sprint("%d of length %d\n", l[n], n));
}

