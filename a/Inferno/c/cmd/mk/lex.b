#
#	initially generated by c2l
#


# 
#  *	Assemble a line skipping blank lines, comments, and eliding
#  *	escaped newlines
#  
assline(bp: ref Iobuf, buf: ref Bufblock): int
{
	c, lastc: int;

	buf.current = 0;
	while((c = nextrune(bp, 1)) >= 0){
		case(c){
		'\r' =>	#  consumes CRs for Win95 
			continue;
		'\n' =>
			if(buf.current != 0){
				insert(buf, 0);
				return 1;
			}
		#  skip empty lines 
		'\\' or '\'' or '"' =>
			rinsert(buf, c);
			if(escapetoken(bp, buf, 1, c) == 0)
				Exit();
		'`' =>
			if(bquote(bp, buf) == 0)
				Exit();
		'#' =>
			lastc = '#';
			while((c = bp.getb()) != '\n'){
				if(c < 0){
					insert(buf, 0);
					return buf.start[0] != byte 0;
				}
				if(c != '\r')
					lastc = c;
			}
			mkinline++;
			if(lastc == '\\')
				break;	#  propagate escaped newlines??
			if(buf.current != 0){
				insert(buf, 0);
				return 1;
			}
		* =>
			rinsert(buf, c);
		}
	}
	insert(buf, 0);
	return buf.start[0] != byte 0;
}

# 
#  *	assemble a back-quoted shell command into a buffer
#  
bquote(bp: ref Iobuf, buf: ref Bufblock): int
{
	c, line, term, start: int;

	line = mkinline;
	while((c = bp.getc()) == ' ' || c == '\t')
		;
	if(c == '{'){
		term = '}';	#  rc style 
		while((c = bp.getc()) == ' ' || c == '\t')
			;
	}
	else
		term = '`';	#  sh style 
	start = buf.current;
	for(; c > 0; c = nextrune(bp, 0)){
		if(c == term){
			insert(buf, '\n');
			insert(buf, 0);
			buf.current = start;
			execinit();
			execsh(nil, buf.start[buf.current: ], buf, envy);
			return 1;
		}
		if(c == '\n')
			break;
		if(c == '\'' || c == '"' || c == '\\'){
			insert(buf, c);
			if(!escapetoken(bp, buf, 1, c))
				return 0;
			continue;
		}
		rinsert(buf, c);
	}
	if(line >= 0)
		sys->fprint(sys->fildes(2), "mk: %s:%d: syntax error; ", libc0->ab2s(infile), line);
	else
		sys->fprint(sys->fildes(2), "mk: %s:%d: syntax error; ", libc0->ab2s(infile), mkinline);
	sys->fprint(sys->fildes(2), "missing closing %c after `\n", term);
	return 0;
}

# 
#  *	get next character stripping escaped newlines
#  *	the flag specifies whether escaped newlines are to be elided or
#  *	replaced with a blank.
#  
savec: int;

nextrune(bp: ref Iobuf, elide: int): int
{
	c, c2: int;

	if(savec){
		c = savec;
		savec = 0;
		return c;
	}
	for(;;){
		c = bp.getc();
		if(c == '\\'){
			c2 = bp.getc();
			if(c2 == '\r'){
				savec = c2;
				c2 = bp.getc();
			}
			if(c2 == '\n'){
				savec = 0;
				mkinline++;
				if(elide)
					continue;
				return ' ';
			}
			bp.ungetc();
		}
		if(c == '\n')
			mkinline++;
		return c;
	}
	return 0;
}

