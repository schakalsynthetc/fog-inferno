Object subclass: #Fish	instanceVariableNames: 't it left right'	classVariableNames: 'IT LEFT RIGHT T'	poolDictionaries: ''	category: 'fish'!!Fish commentStamp: '<historical>' prior: 0!# Fish ## streams and spawn ###Fish is all of a generalized "signal graph", an event stream handler for an interactive windowing terminal with input devices and a shell suitable for interaction and scripting, unified under the "unit", "wire" and "walk" abstractions.A fish unit is 't: x,argv' where 'x' is the head of argument vector and t is a type signature for the verb. Fish units compose into vectors with a left and right terminal, joined by infixes of type schema derived from familiar unix shell operators. The fish unit is the Xt [left | signature, verb, arguments | right ] which is, not coincidentally, an isomorphism of the [receiver, selector, arguments] triple of a Smalltalk message.The fish unit signature [y,x,vector,map] gives type to the positional arguments vector and optional keywords map. Y,X are receiver and selector of a Smalltalk message, executables in a working directory context just as Smalltalk messages are sent to an object context, and thust Y,X in the Fish unit is a generalization of the two.Fish units are joined by left and right tail into a linked list called a Wire. A Fish unit's left and right tail (as well as its function body) have a type identified by symbol, and the links in a wire are of a type determined at the join by binary composition of the types of the two tails.Shell pipelines are by dispatching on types from the 'shell' tail types group, which includes pipe and redirections, the asynchronous invocation '&', sequential synchronous invocation ';', and logical operators on exit status, as well as ternary 'if' and n-ary 'switch' conditionals, and the 'for' looping operator.Anything in a fish unit can be pipelined unix shell style. All fish units thus at least nominally have three IO channels 0,1,2 for the stdio file descriptors, a return value which itself is a fish unit and implies success when nil, a pid (nil if no process is spawned), and the "wdir" property already implicit in Y.The units of a wire are always walked and evaluated in linear order and synchronously, but may spawn an asynchronous process and immediately return a handle to the process.Spawn handles have a pid and stdio channels 0,1,2 plus any other channels set up at invocation, and a process status flag (init,walk,eval,quit).When a process quits the live spawn object representing it becomes a Quit with the return value or an Oops with error status. Quit is always consumed on read, Oops is generally consumed on read but may be an infinite producer or a restart, depending on the type of error.The walk state has a group of subtypes representing rendezvous states. Init state is the state of the spawn unit before the process actually executes, and is generally only seen by fish or fith code if a group of processes are set up to wait for deferred or synchronous start, the Quit state is the remaining from an exited process, as already described. Eval is the state of a process currenty busy and inaccessible to the spawning shell.Wires are walked from a left sentinel "init" to right sentinel "quit", and are circular if the "init" and "quit" nodes are the same node. The sentinel type "loop" is a supertype of both init and quit that sits at the origin of a circular walk -- it must either define a quit condition referentially transparently or declare that it doesn't, so that potential for infinite looping can be known statically before walking down such a wire.Handles to asynchronous spawn are generally returned arranged in a wire circuit that can then be walked cyclically to collect the quit values as they come in.References to a wire are opaque or transparent, opaque having the signature of only the "init" and "quit" nodes, transparent having the signature of all the intermediate nodes.## unit "verb" and "noun" typesVerb is an event, shell command or Smalltalk message. Any Xt that isn't a verb is an object of a verb. For shell purposes every non-verb is either directly an object with a Qid or an indirect reference to an object with a Qid, usually textual, but either way all referents of non-verb fish units have a Qid. Reference is the generalized type encompassing fix filesystem points referenced by path, along with shell environment variables (which are subsumed in a generalized lexical environment type) and literals, along with various other and slightly more exotic types gathered under the abstraction Alphabetical which venti block address (an SHA1 hash of the content), real clock-and-calendar time referencences, tractor points, abstract Unit values for indexing, dimensions and measurement units of various domains (including SI units), and Identity and Location.!Object subclass: #Io	instanceVariableNames: 't it left right streams buffer file iounit xyz ef pqr ghijkl'	classVariableNames: ''	poolDictionaries: ''	category: 'fish'!!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!buffer	^ buffer! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!buffer: anObject	buffer := anObject! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!ef	^ ef! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!ef: anObject	ef := anObject! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!file	^ file! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!file: anObject	file := anObject! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!ghijkl	^ ghijkl! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!ghijkl: anObject	ghijkl := anObject! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:52'!initialize	t := self class.	streams := IoStreams new t: self.	buffer := IoBuffer default t: self.	iounit := IoUnit new t: self.	file := IoFile new t: self.! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!iounit	^ iounit! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!iounit: anObject	iounit := anObject! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!it	^ it! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!it: anObject	it := anObject! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!left	^ left! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!left: anObject	left := anObject! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!pqr	^ pqr! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!pqr: anObject	pqr := anObject! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!right	^ right! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!right: anObject	right := anObject! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!streams	^ streams! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!streams: anObject	streams := anObject! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!t: anObject	t := anObject! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!xyz	^ xyz! !!Io methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:40'!xyz: anObject	xyz := anObject! !Object subclass: #IoBuffer	instanceVariableNames: 't it left right ndata data iounit type hash venti p q r'	classVariableNames: ''	poolDictionaries: ''	category: 'fish'!!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!data	^ data! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!data: anObject	data := anObject! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!hash: anObject	hash := anObject! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!iounit	^ iounit! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!iounit: anObject	iounit := anObject! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!it	^ it! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!it: anObject	it := anObject! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!left	^ left! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!left: anObject	left := anObject! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!ndata	^ ndata! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!ndata: anObject	ndata := anObject! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!p	^ p! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!p: anObject	p := anObject! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!q	^ q! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!q: anObject	q := anObject! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!r	^ r! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!r: anObject	r := anObject! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!right	^ right! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!right: anObject	right := anObject! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!t: anObject	t := anObject! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!type	^ type! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!type: anObject	type := anObject! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!venti	^ venti! !!IoBuffer methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!venti: anObject	venti := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IoBuffer class	instanceVariableNames: ''!!IoBuffer class methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 15:52'!default	^ self new iounit: 1; ndata: 8192; data: (ByteArray new: 8192); p: 0; q: 0; yourself! !Object subclass: #IoFile	instanceVariableNames: 't it left right srv path qid p q r stat e f'	classVariableNames: ''	poolDictionaries: ''	category: 'fish'!!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!e	^ e! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!e: anObject	e := anObject! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!f	^ f! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!f: anObject	f := anObject! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!it	^ it! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!it: anObject	it := anObject! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!left	^ left! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!left: anObject	left := anObject! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!p	^ p! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!p: anObject	p := anObject! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!path	^ path! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!path: anObject	path := anObject! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!q	^ q! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!q: anObject	q := anObject! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!qid	^ qid! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!qid: anObject	qid := anObject! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!r	^ r! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!r: anObject	r := anObject! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!right	^ right! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!right: anObject	right := anObject! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!srv	^ srv! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!srv: anObject	srv := anObject! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!stat	^ stat! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!stat: anObject	stat := anObject! !!IoFile methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!t: anObject	t := anObject! !Object subclass: #IoStream	instanceVariableNames: 't it left right stream direction mode streamClass p q r'	classVariableNames: ''	poolDictionaries: ''	category: 'fish'!!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!direction	^ direction! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!direction: anObject	direction := anObject! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:59'!initStream	stream := (self streamClass) on: it! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:01'!initStream: s	stream := s! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!it	^ it! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!it: anObject	it := anObject! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!left	^ left! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!left: anObject	left := anObject! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!mode	^ mode! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!mode: anObject	mode := anObject! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:54'!p	^ p! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:54'!p: anObject	p := anObject! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:54'!q	^ q! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:54'!q: anObject	q := anObject! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:54'!r	^ r! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:54'!r: anObject	r := anObject! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!right	^ right! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!right: anObject	right := anObject! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!stream	^ stream! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!stream: anObject	stream := anObject! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:59'!streamClass	^ streamClass ifNil: (self class defaultStreamClass)! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:59'!streamClass: anObject	streamClass := anObject! !!IoStream methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!t: anObject	t := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IoStream class	instanceVariableNames: ''!!IoStream class methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:00'!defaultstreamClass	^ ReadWriteStream! !Object subclass: #IoStreams	instanceVariableNames: 't it left right stdin stdout stderr'	classVariableNames: ''	poolDictionaries: ''	category: 'fish'!!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:04'!initialize	stdin := IoStream new t: self; yourself.	stdout := IoStream new t: self; left: stdin; yourself.	stdin right: stdout.	stderr := IoStream new t: self; left: stdin; right: stdout; yourself.	self left: stdin.	self right: stdout.! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!it	^ it! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!it: anObject	it := anObject! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!left	^ left! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!left: anObject	left := anObject! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!right	^ right! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!right: anObject	right := anObject! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!stderr	^ stderr! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!stderr: anObject	stderr := anObject! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!stdin	^ stdin! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!stdin: anObject	stdin := anObject! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!stdout	^ stdout! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!stdout: anObject	stdout := anObject! !!IoStreams methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:43'!t: anObject	t := anObject! !Object subclass: #IoUnit	instanceVariableNames: 't it left right unit orders'	classVariableNames: ''	poolDictionaries: ''	category: 'fish'!IoUnit subclass: #IoUnitDelimited	instanceVariableNames: 'delim'	classVariableNames: ''	poolDictionaries: ''	category: 'fish'!!IoUnitDelimited methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:47'!delim	^ delim! !!IoUnitDelimited methodsFor: 'accessing' stamp: 'jkl 4/21/2019 15:47'!delim: anObject	delim := anObject! !IoUnit subclass: #IoUnitFixed	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'fish'!