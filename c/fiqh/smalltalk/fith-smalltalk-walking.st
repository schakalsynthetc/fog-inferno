Object subclass: #CollectionWalker	instanceVariableNames: 't it left right stream collection here zero succ init next loop quit eval filter loopPredicate streamNextMethod streamClass'	classVariableNames: ''	poolDictionaries: ''	category: 'fith-smalltalk-walking'!!CollectionWalker commentStamp: 'jkl 4/21/2019 16:42' prior: 0!# CollectionWalker ## generic for all manner of walkies ##### Instance Variables	t:		<Object>	it:		<Object>	left:		<Object>	right:		<Object>## generic walkies #We call #init whenever a new stream is allocated, as it is when a collection is assigned (and the stream is opened on it). On normal iteration we get one unit from the stream and call #succ to increment here. If #filter is not nil, we call it to decide whether to evaluate 'it', then either call #eval if not nil and return the evaluated it (the stored it is unevaluated) or just return it. At stream end, we call #loopPredicate to decide whether to loop or quit, calling #loop or #quit accordingly.. If looping, call #zero to reset 'here' and continue from stream beginning (allocating a new stream if not positionable).The props dictionary keeps arbitrary data for use by the walking functions. Subclasses implement methods where the generic uses methods that call blocks in instance variables.!!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!collection	^ collection! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!collection: anObject	collection := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!eval	^ eval! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!eval: anObject	eval := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 17:02'!filter	^ filter ifNil: true! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!filter: anObject	filter := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!here	^ here! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!here: anObject	here := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!init	^ init! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!init: anObject	init := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!it	^ it! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!it: anObject	it := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!left	^ left! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!left: anObject	left := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!loop	^ loop! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!loop: anObject	loop := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 17:02'!loopPredicate	^ loopPredicate ifNil: false! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!loopPredicate: anObject	loopPredicate := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!next	^ next! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!next: anObject	next := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!quit	^ quit! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!quit: anObject	quit := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!right	^ right! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!right: anObject	right := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!stream	^ stream! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!stream: anObject	stream := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:55'!streamClass	^ streamClass ifNil: self class defaultStreamClass! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:55'!streamClass: anObject	streamClass := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:56'!streamNextMethod	^ streamNextMethod ifNil: self class defaultStreamNextMethod! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:49'!streamNextMethod: anObject	streamNextMethod := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 17:08'!succ	succ ifNil: [^ self here + 1 ]. ^succ! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:43'!succ: anObject	succ := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:29'!t: anObject	t := anObject! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 17:04'!zero	zero ifNil: [^0]. ^zero! !!CollectionWalker methodsFor: 'accessing' stamp: 'jkl 4/21/2019 16:49'!zero: anObject	zero := anObject! !!CollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:54'!initStream! !!CollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:53'!on: coll	collection := coll.	self initStream.	! !!CollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:47'!walk	stream atEnd ifTrue: [^ self walkAtEnd].	^ self walkNext.! !!CollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 17:05'!walk: argv	stream atEnd ifTrue: [^ self walkAtEnd: argv].	^ self walkNext: argv.! !!CollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 17:05'!walkAtEnd	^ self walkAtEnd: nil! !!CollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 17:09'!walkAtEnd: argv	self loopPredicate ifTrue: [^ self walkLoop: argv] ifFalse: [^ self walkQuit: argv]! !!CollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:52'!walkLoop	^ self walkLoop: nil! !!CollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:52'!walkLoop: argv	! !!CollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:51'!walkNext	^ self walkNext: nil! !!CollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 17:09'!walkNext: argv	it := stream perform: self streamNextMethod withArguments: argv.	here := self succ.	eval isNil ifTrue: [^ it] ifFalse: [^ eval value: it]! !!CollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:52'!walkQuit	^ self walkQuit: nil! !!CollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:52'!walkQuit: argv	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CollectionWalker class	instanceVariableNames: ''!!CollectionWalker class methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:54'!defaultStreamClass	^ ReadWriteStream! !!CollectionWalker class methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:55'!defaultStreamNextMethod	^ #next! !CollectionWalker subclass: #BasicCollectionWalker	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'fith-smalltalk-walking'!!BasicCollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:58'!loopPredicate	^ false! !!BasicCollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:58'!succ	self here: self here + 1! !!BasicCollectionWalker methodsFor: 'as yet unclassified' stamp: 'jkl 4/21/2019 16:57'!zero	self here: 1.! !CollectionWalker subclass: #InfiniteCycleWalker	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'fith-smalltalk-walking'!